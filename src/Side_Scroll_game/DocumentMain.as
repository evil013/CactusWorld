package {	import flash.display.MovieClip;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.events.Event;	import flash.events.KeyboardEvent;	import MainTimer;	public class DocumentMain extends MovieClip	{		//initial variables		private var currentNumberOfEnemiesOnstage:int;		private var initialNumberOfEnemiesToCreate:int = 2;		private var maxNumberOfEnemiesOnstage:int = 5;		private var ninjaKills:int;		private var childToRemove:int;		private var level:int = 1;		private var e:int = 0;		private var minute:int = 0;		private var second:int = 50;		private var gameTimer:MainTimer;		private var childrenOnStage:int;		private var lastX:int;// variable to determine where the last x of the player was.		private var thePlayer:Player;		private var theEnemy:Enemy;		private var doesTheWorldNeedToScroll:Boolean;		private var makeNewEnemyTimer:Timer = new Timer(3000,1);		private var finishOffEnemy:Timer = new Timer(500,1);		public function DocumentMain()		{			stage.addEventListener(KeyboardEvent.KEY_DOWN, gameStart);		}		private function gameStart(e:KeyboardEvent):void		{			stage.removeEventListener(KeyboardEvent.KEY_DOWN, gameStart);			init();		}		public function init()		{			// constructor code			trace("document main initiated");			hint.text = "Click where to start it";			//Set up the timer			gameTimer = new MainTimer(minute,second);			addChild( gameTimer );			gameTimer.x = 60;			gameTimer.y = 40;			//Set up enemy timer			makeNewEnemyTimer.addEventListener(TimerEvent.TIMER_COMPLETE,makeNewEnemyHandler);			makeNewEnemyTimer.start();			//Set up the player;			thePlayer = new Player();			addChild(thePlayer);			thePlayer.x = stage.stageWidth * 0.1;// halfway across the stage			thePlayer.y = 0;			thePlayer.name = "player";			thePlayer.scaleX = thePlayer.scaleY = 0.4;			//where code add enemy			while (e < initialNumberOfEnemiesToCreate)			{				createEnemy();				e++;			}			ninjaKills = 0;			lastX = thePlayer.x;			childrenOnStage = this.numChildren;//make sure you assign this value after adding children			this.addEventListener(Event.ENTER_FRAME, mainGameLoop);			stage.focus = stage;			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, keyUpHandler);		}		private function mainGameLoop(event:Event):void		{			gameResets();			removeOrCreateNewEnemies();			processCollisions();			scrollStage();			// ends  mainGameLoop		}		private function keyDownHandler(e:KeyboardEvent):void		{			switch ( e.keyCode)			{				case 37 ://left					thePlayer.moveLeft();					break;				case 38 ://up					thePlayer.startJumping();					break;				case 39 ://right					thePlayer.moveRight();					break;				case 40 ://down to attack					thePlayer.attack();					break;			}		}		private function keyUpHandler(e:KeyboardEvent):void		{			switch ( e.keyCode)			{				case 37 ://left				case 39 ://right					thePlayer.standStill();					break;				case 40 ://down to attack					//as a reminder, you COULD do something when you finish attacking.					break;				default :					//anything			}		}//**************************************		//enemy funcitons		private function createEnemy():void		{			theEnemy = new Enemy(  1 );			addChild(theEnemy);			theEnemy.x = (Math.random() * stage.stageWidth) + (stage.stageWidth / 2) ;// anywhere across the stage			theEnemy.y = 0;			theEnemy.name = "enemy";			childrenOnStage = this.numChildren;		}		//判斷如果敵人掉下去 或過頭 重新製造敵人		private function removeOrCreateNewEnemies():void		{			for (var c:int = 0; c < childrenOnStage; c++)			{				if (getChildAt(c).name == "enemy" && getChildAt(c).y > stage.stageHeight)				{					removeChildAt(c);					createEnemy();				}				if (getChildAt(c).name == "enemy" && getChildAt(c).x < thePlayer.x - stage.stageWidth)				{					removeChildAt(c);					createEnemy();				}			}		}		//敵人計數器 和 判斷是否要不要再增加敵人		private function makeNewEnemyHandler(event:TimerEvent):void		{			currentNumberOfEnemiesOnstage = 0;			for (var c:int = 0; c < childrenOnStage; c++)			{				if (getChildAt(c).name == "enemy")				{					currentNumberOfEnemiesOnstage++;				}			}			if (currentNumberOfEnemiesOnstage < maxNumberOfEnemiesOnstage)			{				trace("not enough enemies onstage, make more");				createEnemy();			}			makeNewEnemyTimer.start();		}		//counter kills;		public function finishOffEnemyComplete(event:TimerEvent):void		{			ninjaKills++;			killScoreBox.text = String(ninjaKills) + " KILLS";			removeChildAt( childToRemove);			childrenOnStage = this.numChildren;		}//*********************************************		//Collision funciton begin		private function processCollisions():void		{			//對所有stage上面的物件做碰撞測試			for (var c:int = 0; c < childrenOnStage; c++)			{				//判斷只有玩家物件或地人物件才有地形碰撞				if (getChildAt(c).name == "player" || getChildAt(c).name == "enemy")				{					//如果碰撞					if (_boundaries.hitTestPoint(getChildAt(c).x,getChildAt(c).y,true))					{//if the boundary collides with the player or enemy						while (  _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) )						{							BoundaryObject(getChildAt(c)).incrementUpward();							//bump up the object until it isn't hitting the boundary;							if (_boundaries.hitTestPoint(getChildAt(c).x,getChildAt(c).y,true))							{							}							else							{// once it isn't hitting the boundary, do this function for keeping the object on the boundary								BoundaryObject(getChildAt(c)).keepOnBoundary();							}						}//  ends while (  _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) );					}// ends if ( _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) )				}//ends if ( getChildAt(c).name == "player") 				////////////////////////////////////////////////////////////////////////				////////////////////////////////////////////////////////////////////////				////////////////////////Collision with ENEMIES////////////////				if (getChildAt(c).name == "enemy")				{					if (getChildAt(c).hitTestPoint(thePlayer.x+20,thePlayer.y,true) || getChildAt(c).hitTestPoint(thePlayer.x-20,thePlayer.y,true)  )					{						if (thePlayer.isAttacking == false)						{							// we are being attacked (and not defending)							health.width = health.width - 2;							Enemy(getChildAt(c)).makeEnemyAttack();						}						else						{							// we are attacking that enemy							childToRemove = c;							Enemy(getChildAt(c)).makeEnemyDie();							finishOffEnemy.start();							finishOffEnemy.addEventListener(TimerEvent.TIMER_COMPLETE, finishOffEnemyComplete);						}					}// ends hitTestPoint					else if ( Enemy(getChildAt(c)).enemyIsAttacking == true )					{						//if there isn't a collision between player and enemy, BUT the enemy is attacking						Enemy(getChildAt(c)).makeEnemyStopAttacking();					}				}//if (getChildAt(c).name == "enemy") 			}//ends the for loop					}//ends processCollisions		//if times up, do something to reset the game		private function gameResets()		{			if (gameTimer.timerHasStopped == true)			{				resetBoard();			}			else if (thePlayer.y > stage.stageHeight)			{				resetBoard();			}			else if (_boundaries.pole.hitTestPoint(thePlayer.x,thePlayer.y,true) && doesTheWorldNeedToScroll == false)			{				level++;				trace("LEVEL UP");				_boundaries.nextFrame();				resetBoard();			}			else if (health.width <= 2)			{				resetBoard();			}			// ends  gameResets		}		//reset game (time) function		private function resetBoard():void		{			health.width = 300;			thePlayer.x = stage.stageWidth * 0.5;			_boundaries.x = stage.stageWidth * 0.5;			sky.x = stage.stageWidth * 0.5;			thePlayer.y = 0;			_boundaries.y = 0;			sky.y = 0;			ninjaKills = 0;			gameTimer.resetTimer(0,50);		}		//Control the stage view;		private function scrollStage():void		{			//首先先判斷玩家位置與之前的差別			if (thePlayer.x != lastX)			{				doesTheWorldNeedToScroll = true;			}			else if (thePlayer.x == lastX)			{				doesTheWorldNeedToScroll = false;			}			if (doesTheWorldNeedToScroll == true)			{				sky.x += (stage.stageWidth * 0.5) - thePlayer.x * 1.002;				for (var b:int = 0; b < childrenOnStage; b ++)				{					if (getChildAt(b).name == "enemy")					{						getChildAt(b).x +=  (stage.stageWidth * 0.5) - thePlayer.x;					}				}				_boundaries.x +=  (stage.stageWidth * 0.5) - thePlayer.x;			}			else			{				sky.x -=  0.5;			}			// RUN THIS FOLLOWING LINE LAST			thePlayer.x = stage.stageWidth * 0.5;			lastX = thePlayer.x;		}// end of scrollstage function	}}