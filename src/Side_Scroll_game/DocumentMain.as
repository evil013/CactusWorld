package {	import flash.display.MovieClip;	import flash.display.DisplayObject;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import MainTimer;	public class DocumentMain extends MovieClip	{		//initial variables		private var currentNumberOfEnemiesOnstage:int = 0;		private var initialNumberOfEnemiesToCreate:int = 2;		private var maxNumberOfEnemiesOnstage:int = 5;				private var numChildrenInBoundaries:int;		private var robotKills:int;		private var coninCollect:int;		private var waterCollect:int;		private var sunlightCollect:int;		private var soilCollect:int;				private var childToRemove:int;		private var level:int = 1;		private var e:int = 0;		private var minute:int = 0;		private var second:int = 20;		private var gameTimer:MainTimer;		private var childrenOnStage:int;				private var lastX:int;// variable to determine where the last x of the player was.		private var lastY:int;// variable to determine where the last x of the player was.				private var thePlayer:Player;		private var theEnemy:Enemy;		private var doesTheWorldNeedToScroll:Boolean;		private var doesTheWorldNeedToScrollUp:Boolean;		private var makeNewEnemyTimer:Timer = new Timer(6000,1);		private var finishOffEnemy:Timer = new Timer(510,1);				private var theSoundLibrary:SoundLibrary = new SoundLibrary();		public function DocumentMain()		{			hint.text = "Click where to start it";			trace("document main initiated");						stage.addEventListener(KeyboardEvent.KEY_DOWN, gameStart);						//put the timer(health) on the stage			gameTimer = new MainTimer(minute,second);			addChild( gameTimer );			gameTimer.x = 50;			gameTimer.y = 120;					}		private function gameStart(e:KeyboardEvent):void		{			stage.removeEventListener(KeyboardEvent.KEY_DOWN, gameStart);			trace("game Start");			init();		}		public function init()		{			hint.text = " ";						//Set up the timer			gameTimer.startCount();						//Set up enemy timer			makeNewEnemyTimer.addEventListener(TimerEvent.TIMER_COMPLETE,makeNewEnemyHandler);			makeNewEnemyTimer.start();						//Set up the player;			thePlayer = new Player();			addChild(thePlayer);			thePlayer.x = stage.stageWidth * 0.5;// halfway across the stage			thePlayer.y = stage.stageHeight * 0.5;			thePlayer.name = "player";			thePlayer.scaleX = thePlayer.scaleY = 0.4;						//where code add enemy			while (currentNumberOfEnemiesOnstage < initialNumberOfEnemiesToCreate)			{				createEnemy();				currentNumberOfEnemiesOnstage++;			}						waterScoreBox.text = "(0/2)";			sunlightScoreBox.text = "(0/2)";			soilScoreBox.text = "(0/2)";			robotKills = 0;			lastX = thePlayer.x;			lastY = thePlayer.y;						childrenOnStage = this.numChildren;//make sure you assign this value after adding children			this.addEventListener(Event.ENTER_FRAME, mainGameLoop);			stage.focus = stage;			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, keyUpHandler);		}		private function mainGameLoop(event:Event):void		{			gameResets();			removeOrCreateNewEnemies();			processCollisions();			scrollStage();			// ends  mainGameLoop		}		private function keyDownHandler(e:KeyboardEvent):void		{			switch ( e.keyCode)			{				case 37 ://left					thePlayer.moveLeft();					break;				case 38 ://up					thePlayer.startJumping();					break;				case 39 ://right					thePlayer.moveRight();					break;				case 40 ://down to attack					thePlayer.attack();					break;				case 32 ://press space to get testing result										//trace(thePlayer.x);					trace(_boundaries.x);					//trace(lastY);					trace(childrenOnStage);					break;			}		}		private function keyUpHandler(e:KeyboardEvent):void		{			switch ( e.keyCode)			{				case 37 ://left				case 39 ://right					thePlayer.standStill();					break;				case 40 ://down to attack					//as a reminder, you COULD do something when you finish attacking.					break;				default :					//anything			}		}//**************************************//		ENEMY FUNCTIONS//**************************************		//enemy funcitons		private function createEnemy():void		{			theEnemy = new Enemy(1) //enemy(speed of the robot);			addChild(theEnemy);			theEnemy.x = (Math.random() * stage.stageWidth) + (stage.stageWidth / 2) ;// anywhere across the stage			theEnemy.y = 0;			theEnemy.name = "enemy";			theEnemy.scaleX = theEnemy.scaleY = 0.4;						childrenOnStage = this.numChildren;		}				//判斷如果敵人掉下去 或過頭 重新製造敵人		private function removeOrCreateNewEnemies():void		{			for (var c:int = 0; c < childrenOnStage; c++)			{				if (getChildAt(c).name == "enemy" && getChildAt(c).y > stage.stageHeight)				{					removeChildAt(c);					createEnemy();				}				if (getChildAt(c).name == "enemy" && getChildAt(c).x < thePlayer.x - stage.stageWidth)				{					removeChildAt(c);					createEnemy();				}			}		}		//敵人計數器 和 判斷是否要不要再增加敵人		private function makeNewEnemyHandler(event:TimerEvent):void		{			//currentNumberOfEnemiesOnstage = 0;			for (var c:int = 0; c < childrenOnStage; c++)			{				if (getChildAt(c).name == "enemy")				{					currentNumberOfEnemiesOnstage++;				}			}			if (currentNumberOfEnemiesOnstage < maxNumberOfEnemiesOnstage)			{				trace("not enough enemies onstage, make more");				createEnemy();			}			makeNewEnemyTimer.start();		}		//counter kills;		public function finishOffEnemyComplete(event:TimerEvent):void		{			robotKills++;			killScoreBox.text = String(robotKills) + " KILLS";			removeChildAt(childToRemove);			childrenOnStage = this.numChildren;		}				public function cleanEnemyOnStage():void		{			var deletionArray:Array = [];			var child:DisplayObject;			trace(childrenOnStage);						for (var c:int = 0; c < childrenOnStage; c++)			{				child = getChildAt(c);								if (child.name == "enemy")				{					deletionArray.push(child);					//removeChildAt(c);					//childrenOnStage = this.numChildren;				}			}							for (var j = 0; j<deletionArray.length; j++)			{				this.removeChild(deletionArray[j])			}			childrenOnStage = this.numChildren;			trace(childrenOnStage);		}				//**************************************//		COLLISIONS FUNCTIONS//**************************************		//Collision funciton begin		private function processCollisions():void		{			//對所有stage上面的物件做碰撞測試			for (var c:int = 0; c < childrenOnStage; c++)			{				//判斷只有玩家物件或地人物件才有地形碰撞												if (getChildAt(c).name == "player" || getChildAt(c).name == "enemy")				{					//如果碰撞					if (_boundaries.hitTestPoint(getChildAt(c).x,getChildAt(c).y,true))					{//if the boundary collides with the player or enemy																		while ( _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) )						{															BoundaryObject(getChildAt(c)).incrementUpward();								BoundaryObject(getChildAt(c)).keepOnBoundary();																	//bump up the object until it isn't hitting the boundary;																if (_boundaries._wall.hitTestPoint(getChildAt(c).x,getChildAt(c).y,true))								{																											//BoundaryObject(getChildAt(c)).keepOnBoundary();								}								else								{// once it isn't hitting the boundary, do this function for keeping the object on the boundary									//trace("2");									//temp++;									//BoundaryObject(getChildAt(c)).hitTheWall();								}																						}//  ends while (  _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) );					}// ends if ( _boundaries.hitTestPoint ( getChildAt(c).x , getChildAt(c).y, true) )				}//ends if ( getChildAt(c).name == "player") 								////////////////////////////////////////////////////////////////////////				////////////////////////////////////////////////////////////////////////				////////////////////////Collision with ENEMIES////////////////				if (getChildAt(c).name == "enemy")				{					if (getChildAt(c).hitTestPoint(thePlayer.x+20,thePlayer.y,true) || getChildAt(c).hitTestPoint(thePlayer.x-20,thePlayer.y,true)  )					{												if (thePlayer.isAttacking == false)						{							// we are being attacked (and not defending)							healthBar.health.width = healthBar.health.width - 2;							Enemy(getChildAt(c)).makeEnemyAttack();						}						else						{							// we are attacking that enemy							childToRemove = c;							Enemy(getChildAt(c)).makeEnemyDie();																					finishOffEnemy.start();							finishOffEnemy.addEventListener(TimerEvent.TIMER_COMPLETE, finishOffEnemyComplete);														//gameTimer.addTime();						}					}// ends hitTestPoint										else if ( Enemy(getChildAt(c)).enemyIsAttacking == true )					{						//if there isn't a collision between player and enemy, BUT the enemy is attacking						Enemy(getChildAt(c)).makeEnemyStopAttacking();					}				}//if (getChildAt(c).name == "enemy") 			}//ends the for loop									////////////////////////////////////////////////////////////////////////			////////////////////////////////////////////////////////////////////////			///////////////////////////////////////////////////////			///// new for loop for coins collision detection			numChildrenInBoundaries = _boundaries.numChildren;			for (var d:int = 0; d < numChildrenInBoundaries; d++)			{				if (_boundaries.getChildAt(d).hasOwnProperty("isACoin") && _boundaries.getChildAt(d).visible == true)				{					if (thePlayer.hitTestObject(_boundaries.getChildAt(d)))					{						//trace("hit coin");						coninCollect++;						coinScoreBox.text = String(coninCollect) + " Coins";						theSoundLibrary.coin();												_boundaries.getChildAt(d).visible = false;						//_boundaries.getChildAt(d).y = stage.stageHeight + 300;						//_boundaries.removeChildAt( d );						//numChildrenInBoundaries = _boundaries.numChildren;					}				}								else if (_boundaries.getChildAt(d).hasOwnProperty("isAWater") && _boundaries.getChildAt(d).visible == true)				{					if (thePlayer.hitTestObject(_boundaries.getChildAt(d)))					{						//trace("hit water");						waterCollect++;						waterScoreBox.text = "( " + String(waterCollect) + "/2)";						theSoundLibrary.coin();												_boundaries.getChildAt(d).visible = false;						//_boundaries.getChildAt(d).y = stage.stageHeight + 300;						//_boundaries.removeChildAt( d );						//numChildrenInBoundaries = _boundaries.numChildren;					}				}								else if (_boundaries.getChildAt(d).hasOwnProperty("isASunlight") && _boundaries.getChildAt(d).visible == true)				{					if (thePlayer.hitTestObject(_boundaries.getChildAt(d)))					{						//trace("hit sunlight");						sunlightCollect++;						sunlightScoreBox.text = "( " + String(sunlightCollect) + "/2)";						theSoundLibrary.coin();												_boundaries.getChildAt(d).visible = false;						//_boundaries.getChildAt(d).y = stage.stageHeight + 300;						_boundaries.removeChildAt( d );						numChildrenInBoundaries = _boundaries.numChildren;					}				}								else if (_boundaries.getChildAt(d).hasOwnProperty("isASoil") && _boundaries.getChildAt(d).visible == true)				{					if (thePlayer.hitTestObject(_boundaries.getChildAt(d)))					{						//trace("hit soil");						soilCollect++;						soilScoreBox.text = "( " + String(soilCollect) + "/2)";						theSoundLibrary.coin();												//_boundaries.getChildAt(d).visible = false;						//_boundaries.getChildAt(d).y = stage.stageHeight + 300;						_boundaries.removeChildAt( d );						numChildrenInBoundaries = _boundaries.numChildren;					}				}															}// ends for					}//ends processCollisions		//if times up, do something to reset the game		private function gameResets()		{			if (gameTimer.timerHasStopped == true)			{				resetBoard();			}			else if (thePlayer.y > stage.stageHeight)			{				resetBoard();			}			else if (healthBar.health.width <= 3)			{				resetBoard();			}			else if (_boundaries.pole.hitTestPoint(thePlayer.x - thePlayer.width/2,thePlayer.y,true) && doesTheWorldNeedToScroll == false)			{				level++;				trace("LEVEL UP");				_boundaries.nextFrame();				//resetBoard();			}			// ends  gameResets		}//************************//		RESET//************************		//reset game (time) function		private function resetBoard():void		{			currentNumberOfEnemiesOnstage = 0 ;			cleanEnemyOnStage();						while (currentNumberOfEnemiesOnstage < initialNumberOfEnemiesToCreate)			{				createEnemy();				currentNumberOfEnemiesOnstage++;			}						healthBar.health.width = 200;			thePlayer.x = stage.stageWidth * 0.5;			_boundaries.x = stage.stageWidth * 0.5;			sky.x = stage.stageWidth * 0.5;						waterScoreBox.text = "(0/2)";			sunlightScoreBox.text = "(0/2)";			soilScoreBox.text = "(0/2)";			robotKills = 0;			coninCollect =0;			lastX = thePlayer.x;			//lastY = thePlayer.y;						gameTimer.resetTimer(0,25);						childrenOnStage = this.numChildren;//make sure you assign this value after adding children		}		//Control the stage view;		private function scrollStage():void		{			//首先先判斷玩家位置與之前的差別			if (thePlayer.x != lastX)			{				doesTheWorldNeedToScroll = true;			}			else if (thePlayer.x == lastX)			{				doesTheWorldNeedToScroll = false;			}						if (thePlayer.y != lastY)			{				doesTheWorldNeedToScrollUp = true;							}			else if (thePlayer.y == lastY)			{				doesTheWorldNeedToScrollUp = false;			}						//doesTheWorldNeedToScrollUp			if (doesTheWorldNeedToScroll == true)			{				sky.x += (stage.stageWidth * 0.5) - thePlayer.x * 1.002;	//Background move				_boundaries.x +=  (stage.stageWidth * 0.5) - thePlayer.x;	//World move				for (var b:int = 0; b < childrenOnStage; b ++)				{					if (getChildAt(b).name == "enemy")					{						getChildAt(b).x +=  (stage.stageWidth * 0.5) - thePlayer.x;					}				}			}			else			{				sky.x -=  0.5;			}									if (doesTheWorldNeedToScrollUp == true)			{											}			else			{							}									// RUN THIS FOLLOWING LINE LAST			thePlayer.x = thePlayer.x = stage.stageWidth * 0.5;			lastX = thePlayer.x;			lastY = thePlayer.y;		}// end of scrollstage function	}}