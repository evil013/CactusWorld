package com.dayvid.vector2D{	public class EuclideanVector2D	{		protected var _position:Vector2D = new Vector2D();		protected var _velocity:Vector2D = new Vector2D();		protected var _radius:Number = 10;				public function EuclideanVector2D(aStartPoint:Vector2D = null, aEndPoint:Vector2D = null)		{			if (aStartPoint != null) a = aStartPoint.clone();			if (aEndPoint != null) b = aEndPoint.clone();		}		/**		 * Sets / gets start point of velocity vector.		 */		public function set a(v2:Vector2D):void		{			_position.copy(v2);		}		public function get a():Vector2D		{			return _position.clone();		}		/**		 * Sets / gets end point of velocity vector.		 */		public function set b(v2:Vector2D):void		{			_velocity.x = v2.x - _position.x;			_velocity.y = v2.y - _position.y;		}		public function get b():Vector2D		{			return _position.clone().add(_velocity);		}		/**		 * Sets / gets position of vector as a Vector2D.		 */		public function set position(value:Vector2D):void		{			_position.copy(value);			x = _position.x;			y = _position.y;		}		public function get position():Vector2D		{			return _position;		}		/**		 * Sets / gets velocity of vector as a Vector2D.		 */		public function set velocity(value:Vector2D):void		{			_velocity.copy(value);		}		public function get velocity():Vector2D		{			return _velocity;		}		/**		 * Sets x position of vector.		 */		public function set x(value:Number):void		{			_position.x = value;		}		public function get x():Number		{			return _position.x;		}		/**		 * Sets y position of vector. 		 */		public function set y(value:Number):void		{			_position.y = value;		}		public function get y():Number		{			return _position.y;		}		/**		 * Sets / Gets length position of vector. 		 */		public function get length():Number		{			return _velocity.length;		}		public function set length(aParam:Number):void		{			_velocity.length = aParam;		}		/**		 * Sets / Gets rotation position of vector. 		 */		public function set rotation(value:Number):void		{			if (_velocity.length == 0) _velocity.normalize();			_velocity.angle = value * Math.PI / 180;		}		public function get rotation():Number		{			return _velocity.angle * 180 / Math.PI;		}		/**		 * Sets / Gets rotation angle of vector. 		 */		public function set angle(value:Number):void		{			if (_velocity.length == 0) _velocity.normalize();			_velocity.angle = value;		}		public function get angle():Number		{			return _velocity.angle;		}		/**		 * Sets / Gets radius. Used for circle collisions. 		 */		public function set radius(value:Number):void		{			_radius = value;		}		public function get radius():Number		{			return _radius;		}		//		/**		 * Sets / Gets reverses vector. 		 */		public function reverse():void		{			_velocity.reverse();		}		public function get normalVelocityX():Number		{			return _velocity.clone().normalize().x;		}		public function get normalVelocityY():Number		{			return _velocity.clone().normalize().y;		}		//		public function get rightNormal():EuclideanVector2D		{			var rn:EuclideanVector2D = new EuclideanVector2D();			rn.a = a;			rn.b = a.clone().add(_velocity.perpRight);			return rn;		}		//		public function get leftNormal():EuclideanVector2D		{			var ln:EuclideanVector2D = new EuclideanVector2D();			ln.a = a;			ln.b = a.clone().add(_velocity.perpLeft);			return ln;		}		/**		 * Calculates the dot product of this vector and another given normalized vector, good for dealing with collisions		 * @param v2 Another Vector2D instance.		 * @return Number The dot product of this vector and the one passed in as a parameter.		 */		public function dotProdCollision(v2:EuclideanVector2D):Number		{			var normalizedV2:Vector2D = v2.velocity.clone().normalize();			return _velocity.x * normalizedV2.x + _velocity.y * normalizedV2.y;		}		//		public function perpDotProduct(aV:EuclideanVector2D):Number		{			var v2:Vector2D = aV.velocity.clone().normalize();			var v1ln:Vector2D = leftNormal.velocity;			var perpProduct:Number = v1ln.x *  v2.x + v1ln.y * v2.y;			//You can calculate the same result using 			//the vectors' vx and vy like this:			//var perpProduct:Number = v1.velocity.x * v2.velocity.y - v1.velocity.y * v2.velocity.x;			if(perpProduct != 0)			{				return perpProduct;			}			else			{				return 1;			}		}		//		public function project(aV:EuclideanVector2D):EuclideanVector2D		{			//Find the dot product between this VelocityVector and aV			var dp1:Number = dotProdCollision(aV);						//Find the projection of VelocityVector onto aV			var vx:Number = dp1 * aV.normalVelocityX;			var vy:Number = dp1 * aV.normalVelocityY;						//Add start and end points, if they exist			var aX:Number = 0;			var aY:Number = 0;			var bX:Number = 0;			var bY:Number = 0;						//Create a projection VectorModel to return to the caller			var projectionVector:EuclideanVector2D = new EuclideanVector2D();			if(aV.a.x != 0 && aV.a.y != 0)			{				aX = aV.a.x;				aY = aV.a.y;				bX = aV.a.x + vx;				bY = aV.a.y + vy;				projectionVector.a = new Vector2D(aX, aY);				projectionVector.b = new Vector2D(bX, bY);			}			else			{				projectionVector.a = new Vector2D(0, 0);				projectionVector.velocity = new Vector2D(vx, vy);			}						return projectionVector;		}		// 		public function distanceBtwnVelocityVectors(aV:EuclideanVector2D):Number 		{			return _position.dist(aV.position);		}				public function get circle():Circle		{			return new Circle(this._radius, this.x, this.y);		}				public function clone():EuclideanVector2D		{			var aVelocityVector = new EuclideanVector2D();			aVelocityVector.copy(this);			return aVelocityVector;		}		//		public function copy(aVelocityVector:EuclideanVector2D):void		{			_position = aVelocityVector.position.clone();			_velocity = aVelocityVector.velocity.clone();			_radius = aVelocityVector.radius;		}		//		public function cleanUp():void		{			_position = null;			_velocity = null;		}	}}