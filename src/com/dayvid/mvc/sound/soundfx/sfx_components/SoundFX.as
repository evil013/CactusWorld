package com.dayvid.mvc.sound.soundfx.sfx_components {	import com.dayvid.mvc.model.model_components.ComponentModel;	import com.dayvid.util.SoundPanVol;	import com.dayvid.vector2D.EuclideanVector2D;	import com.dayvid.vector2D.Vector2D;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.utils.Timer;	public class SoundFX extends EventDispatcher	{		private var parentClass:Object;		private var sfx:Sound;		private var soundClass:Class = null;		private var channel:SoundChannel = new SoundChannel();		private var setPanAndVol:SoundPanVol;		private var _sfxPlaying:Boolean;		private var model:ComponentModel;		private var vol:Number;		private var pan:Number;		private var currentDistance:Number;		private var centerScreenEV:EuclideanVector2D;		private var position:Point;		private var xPos:*;		private var thisLoop:Boolean;		private var startPosition:uint;		private var ranStartPosition:Boolean = false;		private var cleanUpWhenCompleted:Boolean = false;		private var cleanedUp:Boolean = false;		private var delay:uint = 0;		private var delayTimer:Timer = new Timer(delay);		// this is set only by the player, it used for global sfx		//public var typeID:uint;				public function SoundFX(aModel:ComponentModel, aSoundClass:Class, aParentClass:Object)		{			//trace("SoundFX");			model = aModel;			_sfxPlaying = false;			soundClass = aSoundClass;			parentClass = aParentClass;						centerScreenEV = new EuclideanVector2D(new Vector2D(model.movieWidth / 2, model.movieHeight / 2));			setPanAndVol = new SoundPanVol();		}				public function playSFX(vars:Object = null):void 		{			if (vars == null) 			{				vars = new Object();			}						// volume			if (vars.vol != null) 			{				vol = vars.vol;			} 			else 			{				vol = model.sfxVolume;			}						if (vars.adjustVol != null) 			{				vol *= vars.adjustVol;				vol = Math.max(0, vol);			} 						// stereo panning			if (vars.pan != null) 			{				pan = vars.pan;			} 			else 			{				pan = 0;			}						// x position for stereo			if (vars.x != null && vars.x is Number) 			{				position = new Point(vars.x, 0);			} 			else if (vars.position != null) 			{				position = vars.position;			}			else 			{				position = null;			}						// solo play back, if true then only one can be played at a time			var solo:Boolean = false;			if (vars.solo != null) 			{				solo = vars.solo;			} 						// for looping			if (vars.loop != null) 			{				thisLoop = vars.loop;			} 			else 			{				thisLoop = false;			}						// sets sound start position in milliseconds			if (vars.startPosition != null) 			{				startPosition = vars.startPosition;			} 			else 			{				startPosition = 0;			}						// random start position			if (vars.ranStartPosition != null) 			{				ranStartPosition = vars.ranStartPosition;			}						// delay			if (vars.delay != null)			{				delay = vars.delay			}			// does an auto clean up when completed			if (vars.cleanUp != null) 			{				cleanUpWhenCompleted = vars.cleanUp;				if (cleanUpWhenCompleted) solo = true;			}						// stop sfx before playing, similar to solo except it restarts the sound instead of waiting for sound to finish playing			if (vars.restart != null) 			{				if (vars.restart) stopSFX();			}						if (_sfxPlaying && solo) 			{				// do nothing, makes sure only one sfx plays at a time and waits till completed before starting sfx				setSoundTransform(vol, pan, position);			} 			else 			{								if (delay > 0 && !delayTimer.running)				{					delayTimer = new Timer(delay);					delayTimer.addEventListener(TimerEvent.TIMER_COMPLETE, delayTimerComplete);					delayTimer.start();				}				else				{					playSFXPassed();				}			}		}				private function delayTimerComplete(event:TimerEvent):void		{			delayTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, delayTimerComplete);			if (delay > 0) playSFXPassed();		}				private function playSFXPassed():void		{			if (!cleanedUp && soundClass != null)			{				_sfxPlaying = true;				// problem with play sfx to quickly, transform doesnt change the preceeding calls				//setSoundTransform(vol, pan, position);				//channel = new SoundChannel();								var thisSFX:Sound = new soundClass();								if (ranStartPosition)				{					startPosition = Math.floor(Math.random() * thisSFX.length);				}								if (thisLoop && !ranStartPosition) 				{					channel = thisSFX.play(startPosition, 1000);				} 				else 				{					//trace("thisSFX: " + thisSFX);					channel = thisSFX.play(startPosition, 1);										//trace("channel: " + channel);					if (channel == null) channel = thisSFX.play(startPosition, 1);										//trace("channel: " + channel);					if (channel != null) channel.addEventListener(Event.SOUND_COMPLETE, soundComplete);				}								if (channel != null) setSoundTransform(vol, pan, position);			}		}				public function setSoundTransform(aVol:Number = 1, aPan:Number = 0, aPosition:Point = null):void 		{			position = aPosition;						vol = aVol;						if (model.soundFXDistanceFadeStartPoint > 0 && aPosition != null)			{				centerScreenEV.b = new Vector2D(aPosition.x, aPosition.y);				currentDistance = centerScreenEV.length;				var currentFadeDistance:Number = currentDistance - model.soundFXDistanceFadeStartPoint;								if (currentFadeDistance > model.soundFXFadeRange)				{					vol = 0;				}				else if (currentFadeDistance > 0)				{					// start fade					vol = vol - (vol * (currentFadeDistance / model.soundFXFadeRange));					// make sure vol isn't below 0					vol = Math.max(vol, 0);				}			}						//trace("position: " + position + ", currentDistance: " + currentDistance + ", currentFadeDistance: " + currentFadeDistance + ", vol: " + vol);			pan = aPan;						if (position != null)			{				xPos = position.x;			}			else			{				xPos = null;			}						if (position != null && model != null) 			{				if (channel != null) setPanAndVol.adjustSound(channel, vol, aPan, xPos, model.panWidth, model.movieWidth);			} 			else 			{				if (channel != null) setPanAndVol.adjustSound(channel, vol, aPan);			}		}				public function changeVolume(aNum:Number):void		{			setSoundTransform (aNum, pan, position);		}				private function soundComplete(event:Event):void 		{			event.currentTarget.removeEventListener(Event.SOUND_COMPLETE, soundComplete);			dispatchEvent(new Event(Event.SOUND_COMPLETE));						// if loop is true and random start position is true, then do a reset and play the sfx again			if (ranStartPosition && thisLoop)			{				ranStartPosition = false;				startPosition = 0;				playSFXPassed();			}			else			{				_sfxPlaying = false;				if (cleanUpWhenCompleted) cleanUp();			}		}				public function stopSFX():void 		{			if (delayTimer != null) 			{				delayTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, delayTimerComplete);				delayTimer.stop();			}			if (channel != null) channel.stop();			_sfxPlaying = false;			delay = 0;		}				public function get sfxPlaying():Boolean		{			return _sfxPlaying;		}				public function cleanUp(stopTheSFX:Boolean = true):void 		{			if (!stopTheSFX && _sfxPlaying)			{				// don't stop sound fx until it is finished				cleanUpWhenCompleted = true;			}			else			{				stopSFX();				if (parentClass)				{					parentClass.removeSFX(this);					parentClass = null;					model = null;				}				if (channel != null) 				{					channel.removeEventListener(Event.SOUND_COMPLETE, soundComplete);					channel = null;				}				if (sfx != null) sfx = null;				if (soundClass != null) soundClass = null;				if (model!= null) model = null;								if (setPanAndVol != null) setPanAndVol = null;				if (centerScreenEV != null) 				{					centerScreenEV.cleanUp();					centerScreenEV = null;				}								delayTimer = null;				cleanedUp = true;			}		}	}}